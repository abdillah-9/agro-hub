MIGRATIONS USING KNEX 

Installation:-
1. install (pg or sqlite or mysql or all of them based on ur needs) by 
npm install knex pg OR npm install knex mysql2 OR npm install knex sqlite3

2. create knexFile.js
npx knex init

3. update it based on ur setup EG:
// Update with your config settings.

/**
 * @type { Object.<string, import("knex").Knex.Config> }
 */
module.exports = {

  development: {
    client: 'mysql2',
    connection: {
      host: 'localhost',
      user: 'root',
      password: '',
      database: 'agrohub'
    },
    migrations: {
      directory: './migrations'
    }
  },

  staging: {
    client: 'mysql2',
    connection: {
      host: 'localhost',
      user: 'root',
      password: '',
      database: 'agrohub'
    },
    pool: {
      min: 2,
      max: 10
    },
    migrations: {
      directory: './migrations',
      tableName: 'knex_migrations'
    }
  },

  production: {
    client: 'mysql2',
    connection: {
      host: 'localhost',
      user: 'root',
      password: '',
      database: 'agrohub'
    },
    pool: {
      min: 2,
      max: 10
    },
    migrations: {
      directory: './migrations',
      tableName: 'knex_migrations'
    }
  }

};
_______________________________________________________________________________________________________

Usage:-

1. create migration file
npx knex migrate:make create_users_table

2. edit your migration to fit your needs EG:
exports.up = function(knex) {
  return knex.schema.createTable('users', function(table) {
    table.increments('id'); // AUTO_INCREMENT + PRIMARY KEY
    table.string('fname', 20).notNullable();
    table.string('lname', 20).notNullable();
    table.string('username_or_email', 30).notNullable();
    table.string('user_password', 20).notNullable();
    table.string('user_role', 10).notNullable();
  });
};

exports.down = function(knex) {
  return knex.schema.dropTable('users');
};

3. Run migration file (choose whether its development or production)
npx knex migrate:make create_users_table --env development 

4. Rollback Migrations
npx knex migrate:rollback --env development

NB: Above command rollback/delete the latest batch of migration (migration files ran in the same migrate command).

npx knex migrate:rollback --all --env development

NB: Above command is dangerous in production COZ it deletes all tables hence you'll loose users' data, hence -
do it in development only...
_________________________________________________________________________________________________________________

How to solve failed migration file (Migration file ran successful but actual table/expected changes failed)

1. Delete the broke migration file

2. Run this command in SQL dashboard the remove the cached knex activity
DELETE FROM knex_migrations WHERE name LIKE '%resources.js%';

3. Then re-create that migration and run it.
_________________________________________________________________________________________________________________

GRAPH-QL GUIDANCE

How Query works

âœ… 1. If price or name is missing from the GraphQL requestâ€¦
Example mutation:
mutation UploadCrop($name: String!, $price: Int!) {
  uploadCrop(name: $name, price: $price) {
    id
    success
    message
  }
}

Then the client sends:
{
  "query": "...",
  "variables": {
    "name": "Maize"
    // price is missing âŒ
  }
}

ðŸ”¥ RESULT:

âŒ Yes â€” the GraphQL server will throw an error immediately (even before your resolver runs):

{
  "errors": [
    {
      "message": "Variable \"$price\" of required type \"Int!\" was not provided.",
      ...
    }
  ]
}


âœ… So you're right: backend throws the error automatically via GraphQL engine.

âœ… 2. If response fields (id, success, message) are missing from the server responseâ€¦

Example expectation from frontend:

uploadCrop(...) {
  id
  success
  message
}


But what if your backend (resolver) only returns:

return {
  success: true
}

ðŸ”¥ RESULT:

The frontend does not throw an error.

GraphQL will return null for any missing fields.

{
  "data": {
    "uploadCrop": {
      "id": null,
      "success": true,
      "message": null
    }
  }
}


So:

âœ… No error is thrown on frontend.

â— But itâ€™s up to you to check for null values and handle them properly in UI.

âœ… 3. If you request a field that does NOT exist in schema (e.g. you type uploadCrops instead of uploadCrop)
âŒ YES â€” thatâ€™s an immediate error.

Example:

mutation {
  uploadCrops(name: "Maize", price: 1200) {
    id
  }
}


But backend only has uploadCrop, not uploadCrops.

ðŸ”¥ RESULT:
{
  "errors": [
    {
      "message": "Cannot query field \"uploadCrops\" on type \"Mutation\"."
    }
  ]
}


âœ… This is caught by GraphQL during validation, before it even runs your code.

âœ… Final Summary
Scenario	What Happens
Missing required variable (String!, Int!)	âŒ GraphQL backend throws validation error immediately
Missing field in server response (id, message)	âœ… No error, just null returned to frontend
Typo in operation name or field (uploadCrops)	âŒ GraphQL error: field not found in schema
_______________________________________________________________________________________________________


############### MULTER HANDLE ERRORS and return res.json to users not silently fault ##############
const multer = require('multer');

const storage = multer.diskStorage({
  destination: 'uploads/',
  filename: (req, file, cb) => cb(null, Date.now() + '-' + file.originalname)
});

const upload_image = multer({
  storage,
  fileFilter: (req, file, cb) => {
    const allowed_mime_types = ['image/jpeg', 'image/jpg', 'image/png'];

    if (!allowed_mime_types.includes(file.mimetype)) {
      req.wrong_mime_type = "wrong mime type";
      return cb(new Error("wrong mime type"), false);
    }

    cb(null, true);
  },
  limits: { fileSize: 1024 * 1024 } // still enforce limit
}).single('image');

// Middleware wrapper to catch Multer's fileSize error
function handleMulterError(err, req, res, next) {
  if (err) {
    if (err.code === 'LIMIT_FILE_SIZE') {
      return res.status(400).json({ error: 'File too large (>1MB)' });
    }
    if (req.wrong_mime_type) {
      return res.status(400).json({ error: req.wrong_mime_type });
    }
    return res.status(400).json({ error: err.message });
  }
  next();
}


